<img width="100%" src="https://github.com/kminsmin/nbcamp_unity/assets/114645806/a458479d-5fa7-4b28-9552-fb14ff410312)"/>   

# 내일배움캠프 14일차    
코드카타, 팀프로젝트 다이어그램 작성 및 역할분담   

     
아침에 코드카타 시간에는 각자 1시간동안 코딩테스트 연습문제를 풀고, 점심시간까지 팀프로젝트 다이어그램 작성 및 역할분담을 진행한 뒤, 오후에 각자 맡는 파트를 개발하는 시간을 가졌다.  

## 코드카타 - x만큼 간격이 있는 n개의 숫자
### 문제 설명

<p>함수 solution은 정수 x와 자연수 n을 입력 받아, x부터 시작해 x씩 증가하는 숫자를 n개 지니는 리스트를 리턴해야 합니다. 다음 제한 조건을 보고, 조건을 만족하는 함수, solution을 완성해주세요.</p>

<h4>제한 조건</h4>

<ul>
<li>x는 -10000000 이상, 10000000 이하인 정수입니다.</li>
<li>n은 1000 이하인 자연수입니다.</li>
</ul>

<h4>입출력 예</h4>
<table class="table">
        <thead><tr>
<th>x</th>
<th>n</th>
<th>answer</th>
</tr>
</thead>
        <tbody><tr>
<td>2</td>
<td>5</td>
<td>[2,4,6,8,10]</td>
</tr>
<tr>
<td>4</td>
<td>3</td>
<td>[4,8,12]</td>
</tr>
<tr>
<td>-4</td>
<td>2</td>
<td>[-4, -8]</td>
</tr>
</tbody>
      </table>

> 출처: 프로그래머스 코딩 테스트 연습, https://programmers.co.kr/learn/challenges

처음에는 간단히 풀 수 있을 줄 알았다...  
문제 설명에는 리스트를 리턴하라고 되어 있는데, 주어진 Solution.cs에는 기본 리턴값이 long[] 배열로 되어있길래 일단 그대로 진행했다. 리턴할 answer를  크기 n의 배열로 선언해주고, for문을 이용해서 정수 i를 1부터 n까지 1씩 증가하면서 x * i 값을 answer 배열에 넣어주면 된다고 생각했다. 
이런 방식으로 테스트 케이스들은 간단히 통과했다. 하지만 채점을 해보니 케이스 13, 14에서 실패가 떴다.   
  
케이스 13, 14 실패 코드 :   
```cs
public class Solution {
    public long[] solution(int x, int n) {
        long[] answer = new long[n];
        for (int i = 1; i <= n; i++)
        {
            answer[i-1] = (long)(x*i); //이제는 안다..여기서 오버플로우가 발생했다는 것을...
        }
        return answer;
    }
}
```

x의 최대값이 10000000이고, n의 최대값이 1000이므로, 배열에 들어갈 수 있는 최대 숫자가 100000000000이므로, 주어진 long 자료형이 표현할 수 있는 범위를 넘어서 오버플로우가 일어난다고 생각이 들어서, ```answer[i-1] = (long)(x*i);``` 에서 캐스팅하는 자료형을 ulong으로 바꿔보기도 했다. 
하지면 ulong은 음수를 표현할 수 없었고, 다시 검색해보니 해당 문제에서 만들어질 수 있는 최대 숫자는 long 자료형이 표현할 수 있는 최대 숫자보다 터무니없이 작았으므로, 오버플로우 문제도 아닌 것 같았다. 하지만 수많은 자료를 참고하고 고민해본 결과, 오버플로우 문제가 맞았다. 이전에
확인했듯이 해당 문제에서 등장할 수 있는 가장 큰 숫자는 10000000 x 1000 = 10000000000 (백억)이다. 큰 숫자지만, 이는 long 자료형이라면 충분히 담을 수 있는 크기이다. 하지만 int 자료형은 담을 수 없다. int 자료형이 담을 수 있는 최대 크기는 2,147,483,647이다. 위의 코드에서 문제의
라인은 ```(long)(x*i)```부분이었다. ```x*i```를 먼저 실행하면 백억이 나올 수 있다. 하지만 해당 연산은 int X int 이므로, 결과물도 int 자료형을 가진다. 하지만 연산 결과가 int 자료형이 담을 수 있는 최대값보다 크므로, 오버플로우가 일어난 것이었다. 즉 long 자료형으로의 캐스팅을 연산
후가 아니라 연산 전에 해주면 해결되는 문제였다. 둘 다 long으로 캐스팅 해주지 않고 하나만 long으로 캐스팅해주면 연산 결과는 long으로 나오기 때문에, 간단하게 ```(x * i)``` 주변의 괄호를 지워주는 것으로 문제를 해결했다.   
  
오버플로우 해결 코드 :   
```cs
public class Solution {
    public long[] solution(int x, int n) {
        long[] answer = new long[n];
        for (int i = 1; i <= n; i++)
        {
            answer[i-1] = (long)x*i;
        }
        return answer;
    }
}
```  
## 팀프로젝트 - 다이어그램 작성  
팀프로젝트의 본격적인 개발에 돌입하기에 앞서 팀원들과 함께 다이어그램을 작성하고 역할을 분담했다. 그동안 혼자 개발하면서 다이어그램은 작성해본 적이 없었는데, 확실히 다이어그램을 먼저 작성하고 나니 전체적인 코드의 흐름이 보이고 업무 분담을 하기도 쉬운 것 같다. 



<img width="100%" src="https://github.com/kminsmin/Unity-Projects/assets/114645806/d22f26e7-f8bd-4a79-b94b-c7db64bb0e4e"/>  
