# 내일배움캠프 58일차 TIL    
오늘도 오전에 기술면접 예상질문을 풀어보고 팀 프로젝트 개발을 진행했다. 오늘은 특별히 지금까지 개발한 모든 기능을 연결하여 MVP를 구현해보고 부족한 점들을 찾아내고 이번주를 회고하는 시간을 가졌다.  

## 제네릭이란 무엇인가요?  
- 데이터 요소 타입을 확정하지 않고 데이터 타입 자체를 타입 파라미터로 받아들이도록 클래스 내부의 멤버 변수의 타입을 일반화시킨 클래스입니다.  
- 제네릭은 여러 데이터 형식에서 동일한 로직을 구현할 때, 컬렉션 타입에서 다양한 데이터 형식을 저장하고 관리할 때, 데이터 형식에 따라 다른 연산을 수행해야 할 때 objec타입을 사용했을 때의 문제점을 해소할 수 있습니다. 즉 불필요한 클래스 구현을 방지하고, 타입 검사가 엄격하므로 애플리케이션 배포 전 미리 문제를 해결할 수 있고, 명시적 변환보다 속도가 빠르므로 코드의 재사용성과 유연성이 향상됩니다.

  ## 팀 프로젝트 회고
 - ### 이번주에 구현한 기능들
      -  DungeonGenerator  
      사용한 기술스택 : 재귀호출, switch문, 람다, Linq  
      한 방을 생성하면, 입구로 쓰인 문을 제외하고 나머지 문들을 기준으로 다시 방을 생성하는 메서드를 호출하여, 일정 방 개수에 도달할 때까지 무작위 방향과 구조로 방들이 생성되도록 재귀호출을 사용했다. 문들의 종류를 정의하기 위해 열거형 상수를 만들어 switch문을 통해 문의 종류에 따라 적합한 다음 방을 생성하도록 했고, 우선적으로 방을 생성할 문을 무작위로 선택하기 위해 람다 및 Linq의 OrderBy 메서드를 사용했다.     
      - Player, PlayerStatus  
      사용한 기술스택 : 빌더 패턴, 옵저버 패턴, 코루틴    
      Player 객체를 생성할 때, 불완전한 객체 생성을 방지하기 위해 빌더 패턴으로 구현했다. '강인함'이라고 하는 체력과 비슷한 개념의 게이지가 있는데, 강인함이 0에 도달할 때 게임 오버 처리를 옵저버 패턴으로 구현했다. 현재는 탐험 결과 UI를 출력하는 메서드밖에 연결되어 있지 않지만, 추후 다양한 기능을 추가할 예정이기 때문에 확장성을 고려하여 옵저버 패턴을 채택했다. 또한 일정 시간마다 강인함 게이지를 감소해야 하는데, Update에 구현하기에는 굳이 매 프레임마다 강인함을 감소할 필요가 없다고 생각해서, 특정 시간마다 강인함을 감소시키도록 코루틴으로 구현했다.    
      - Weapon  
      사용한 기술스택 : 전략 패턴, 인터페이스  
      모든 무기는 공통적으로 Catch라는 기능을 수행한다. 하지만 각 무기마다 Catch의 작동 방식은 달라야 한다. 또한 어떤 무기는 Special 기능을 가지고 있지만, 나머지 무기는 그렇지 않다. 때문에 무기들의 공통점과 차이점을 구별하고, 다르게 작동해야 하는 부분을 인터페이스로 만들고, 각 인터페이스를 구현한 별도의 클래스들을 만들어서 전략 패턴으로 무기들을 구현했다.  

  - ### 개선이 필요한 부분
      - DungeonGenerator -방을 생성하는 메서드를 재귀호출하여, 연결 가능 여부만을 고려하여 방을 생성하다 보니 방들의 위치가 겹치게 생성될 때가 있다. 내가 생각해낸 최선의 방법은 방을 생성할 때 방의 중심 좌표를 리스트에 추가하고, 다음 방을 생성할 때는 해당 리스트의 모든 좌표를 검사하여 생성할 방의 좌표와 이전 모든 방들의 좌표와의 거리가 일정 크기 이상이어야 생성이 가능하도록 하는 것이었고, 현재 그렇게 구현이 되어 있는 상황이지만 아직도 가끔씩 방 한두개씩 겹쳐서 생성되는 현상이 종종 발생한다. 방들이 겹쳐서 생성되지 않도록 하는 더 나은 방법이 있는지 지 더 고민해봐야겠다.  
